# Архитектура командной оболочки

## Главный цикл

![](/images/main_loop.svg)

Программа представляет собой цикл из 4 этапов:
1. *Ввод строки* -- получение строки от пользователя;
2. *Подстановка значений переменных* -- преобразование строки;
3. *Парсинг строки* -- получение примитива или синтаксической ошибки;
4. *Диспетчеризация команд* -- получение примитива с дополнительной информацией или ошибки;
5. *Выполнение команд* -- получение флага, нужно ли завершить работу оболочки или нет.

Более подробно о каждом из этапов см. ниже.

Также существует отдельный "модуль" для хранения значений переменных окружения, к которому этап *Подстановка значений переменных*
имеет доступ на чтение, а этап *Выполнение команд* -- на чтение и запись.

## Ввод строки

Состоит из 2 шагов:
1. *Вывод приветствия* (в нашем случае строки "$ ")
2. *Чтение пользовательской программы*, оканчивающейся знаком перевода строки

## Подстановка значений переменных

![](/images/substitutor.svg)

Обработка строки, полученной на предыдущем этапе, выполняется с помощью *модифицированного* конечного автомата. А именно кроме
посимвольного чтения входной строки и переходу по символам в состояния будем также хранить буфер результата `R` и буфер имени
переменной `N`.

Нотация следующая:
* Чёрная стрелка -- запись прочитанного символа в `R`;
* Оранжевая стрелка -- nop;
* Зелёная стрелка -- запись прочитанного символа в `N`;
* Если предыдущий переход был сделан не по чёрной стрелке, а текущий -- по чёрной (или мы достигли конца строки), то записываем
в `R` строку из переменной с именем из `N` с последующим очищением `N`;
* ЛСИП -- латинский символ или подчёркивание;
* Стрелка без подписи означает переход по любому символу.

## Парсинг строки

![](/images/primitive.svg)

TODO

## Диспетчеризация команд

![](/images/primitive++.svg)

В случае, если примитив является присваиванием, то на этой стадии ничего не происходит. Иначе каждая команда в списке
анализируется и отождествляется с одним из 3 листовых классов из диаграммы выше.

Также на этом этапе:
* Для специальных и внутренних команд проверяется правильность количества аргументов;
* Для внешних команд ищется конкретный путь до неё через `PATH` и проверяется наличие разрешения на вызов;
* Для множества команд, написанных через pipe, проверяется отсутствие среди них специальной команды.

## Выполнение команд

Выполнение *примитива* происходит следующим образом:
* при присваивании обновляем хранилище переменных
* при списке команд выполняем их с перенаправлением ввода/вывода

Выполнение *команды* происходит следующим образом:
* специальная команда влияет на работу оболочки (в частности `exit` завершает работу)
* внутренняя исполняется самой оболочкой (в частности `echo` пишет в вывод свои аргументы)
* внешняя запускается по пути с соответствующими аргументами
