# Архитектура CLI

Команда:

* Кузиванов Сергей
* Самсонов Павел
* Суркис Антон

## Главный цикл

![](./images/main_loop.svg)

Программа представляет собой цикл из 4 этапов:
1. *Ввод строки* — получение строки от пользователя;
2. *Подстановка значений переменных* — преобразование строки;
3. *Парсинг строки* — получение примитива или синтаксической ошибки;
4. *Диспетчеризация команд* — получение примитива с дополнительной информацией или ошибки;
5. *Выполнение команд* — получение флага, нужно ли завершить работу оболочки или нет.

Более подробно о каждом из этапов см. ниже.

Также существует отдельный "модуль" для хранения значений переменных окружения, к которому этап *Подстановка значений переменных*
имеет доступ на чтение, а этап *Выполнение команд* — на чтение и запись.

## Ввод строки

Состоит из 2 шагов:
1. *Вывод приветствия* (в нашем случае строки "$ ")
2. *Чтение пользовательской программы*, оканчивающейся знаком перевода строки

## Подстановка значений переменных

![](./images/substitutor.svg)

Обработка строки, полученной на предыдущем этапе, выполняется с помощью *модифицированного* конечного автомата. А именно кроме
посимвольного чтения входной строки и переходу по символам в состояния будем также хранить буфер результата `R` и буфер имени
переменной `N`.

Нотация следующая:
* Чёрная стрелка — запись прочитанного символа в `R`;
* Оранжевая стрелка — nop;
* Зелёная стрелка — запись прочитанного символа в `N`;
* Если предыдущий переход был сделан не по чёрной стрелке, а текущий — по чёрной (или мы достигли конца строки), то записываем
в `R` строку из переменной с именем из `N` с последующим очищением `N`;
* ЛСИП — латинский символ или подчёркивание;
* Стрелка без подписи означает переход по любому символу.

## Парсинг строки

![](./images/primitive.svg)

![](./images/parser2.svg)

Давайте сразу создадим словарь символов на который будем в дальнейшем опираться:
- Элиминирующие символы: двойчные (`"`) и одинарные кавычки (`'`);
- Символ присваивания: `=`;
- Символ разбиения команд: `|`;
- Символ разбивающий слова: пробел (` `).

Наш парсинг разделён на три иерархически связных блока:
* **Ввод первого слова** — тут мы обрабатываем первое слово для того, чтобы понять какому блоку отдать управление в дальнейшем.
  - **Условия ошибок**:
    1. Находясь в состоянии обработки элиминирующих символов мы можем встретить конец строки, который приведёт к незавершённости элиминирующей строки, тем самым это будет синтаксической ошибкой.
* **Ввод присваивания** — тут будет происходить присваивание переменной, где всё, что справа от символа присваивания будет являться значением, которое по нашей семантике мы будем сохранять по имени находящимся слева от знака символа присваивания.
  - **Условия ошибок**:
    1. Такая же обработка ошибок связанная с элиминирующими символами, как и в блоке ввода первого слова;
    2. Если мы встретим символ разделяющий на слова вне любых элиминирующих символов, то мы должны будем выдать ошибку, ведь мы предполагали, что всё, что правее символа присваивания должно быть единым словом, чтобы его можно было правильно интепретировать как значение. Ведь иначе нам будет не понятно, что имел ввиду пользователь.
* **Ввод команды** — если же мы не встретили знак присваивания или встретили конец строки или встретили любой символ, который не входит в слово (символ пробела) из состояния обработки обычных символов в вводе первого слова, то мы можем попытаться нашу общую строчку разбить на слова с помощью соотвествующего символа или на команды через символ разбиения на команды.
  - **Свойства:**
    - Состояние разбиения слов лишь ставит флаг о том, что если мы встретим символ входяший в новое слово, то мы начнём новое слово, а иначе разделяющий символ для слов, который идёт несколько раз подряд или который стоял перед символом, который не входит в новое слово -- просто проигнорируется (например если пробелы будут стоять перед символами разбиения на команды, то мы не будем начинать новое слово уже в предыдущей команде);
    - Кавычки мы обрабатываем аналогичным способом, как и в блоках выше;
    - Состояние разбиения команд будет ожидать символ входящий в новое слово, чтобы вернуть управление уже состоянию ввода команды, где командой уже будет являться новая последовательность слов.
  - **Условия ошибок**:
    1. Такая же обработка ошибок связанная с элиминирующими символами, как и в блоке ввода первого слова;
    2. Если находясь в состоянии разбиения команд мы встретили ещё один символ разбиения команд, то у нас получается, что команда является пустой -- а это, в свою очередь, невалидная конструкция.

Во всех остальных случаях конец строки является валидным состоянием и мы отдаём распарсшенную строчку дальнейшим модулям.

## Диспетчеризация команд

![](/images/primitive++.svg)

В случае, если примитив является присваиванием, то на этой стадии ничего не происходит. Иначе каждая команда в списке
анализируется и отождествляется с одним из 3 листовых классов из диаграммы выше.

Также на этом этапе:
* Для специальных и внутренних команд проверяется правильность количества аргументов;
* Для внешних команд ищется конкретный путь до неё через `PATH` и проверяется наличие разрешения на вызов;
* Для множества команд, написанных через pipe, проверяется отсутствие среди них специальной команды.

## Выполнение команд

Выполнение *примитива* происходит следующим образом:
* при присваивании обновляем хранилище переменных
* при списке команд выполняем их с перенаправлением ввода/вывода

Выполнение *команды* происходит следующим образом:
* специальная команда влияет на работу оболочки (в частности `exit` завершает работу)
* внутренняя исполняется самой оболочкой (в частности `echo` пишет в вывод свои аргументы)
* внешняя запускается по пути с соответствующими аргументами
